# 编译加速 - 合并源文件

> MindSpore

MindSpore包含1000+算子，每个算子有独立的infer和不同后端kernel文件。大量源文件导致编译性能低下。

且各算子源文件包含大量重复内容，如不同算子kernel引用了相同的定义了公共常量的头文件，
则每个kernel编译生成的目标文件都会包含一份这些常量的副本。

为了优化编译时间和目标文件体积，决定将不同算子的infer和kernel源文件合并后编译。具体的合并方案为

- 按照算子首字母进行合并，生成合并文件如ops_infer_a.cc, ops_infer_b.cc, ...
- 文件行数超过10000行时，另起新合并文件，合并文件后缀+1, 如ops_infer_s1.cc
- 合并生成的文件和上次编译的合并文件做md5值比较，确认内容有变化后更新文件内容

为了解决合并后符号名冲突问题，使用脚本为将每个算子源文件包含在以算子名命名的命名空间中。

**结果**：

|                | Release        | Debug         |
|----------------|---------------|---------------|
| Compile Time   | 123min->75min | 123min->83min |
| Whl Size       | 473M->418M    | 5.3G->3.4G   |

在编译时间和目标文件体积上有较大提升。

以下分析来自DeepSeek: 

## 1. 编译时间减少的原因

### (1) 预处理阶段优化
- **头文件重复解析减少**  
  合并前，每个源文件独立编译时需重复解析相同的头文件（如基类头文件、公共工具头文件）。合并后，这些头文件只需解析一次，大幅减少预处理时间。

  *示例：若1000个文件均包含`<vector>`和`<string>`，合并后只需解析两次，而非2000次。*

### (2) 编译阶段优化
- **模板实例化共享**  
  C++模板在编译时会为不同类型生成多份代码（实例化）。合并后，相同模板实例化只需进行一次，避免重复生成。

  *示例：`std::vector<BaseClass>`若在多个文件中使用，合并后只需实例化一次。*

- **内联函数优化**  
  内联函数（如头文件中的`inline`函数）在合并后只需生成一次，避免多文件重复生成。

### (3) 链接阶段优化
- **目标文件数量减少**  
  合并前，1000个源文件生成1000个.o文件，链接器需逐个处理符号解析和重定位。合并后仅需处理10+个.o文件，链接器工作量指数级下降。

## 2. 动态库体积减少的原因

### (1) 符号重复消除（Duplicate Symbol Elimination）
- **模板和隐式代码重复**  
  合并前，每个源文件独立编译时可能生成相同的模板实例化代码（如`std::map<int, BaseClass>`），导致多个.o文件包含重复符号。合并后，链接器可自动去重。

  *示例：若100个文件均实例化`std::vector<BaseClass>`，合并后仅保留一份实例化代码。*

- **内联函数和静态数据重复**  
  头文件中的内联函数和静态变量（如`static int counter;`）会在每个包含它的源文件中生成副本。合并后仅生成一份副本。

### (2) 链接器优化（Linker Optimizations）
- **未使用符号裁剪（Dead Code Elimination）**  
  链接器在合并后的更大编译单元中更容易识别未使用的函数或数据，直接移除。

  *示例：若某函数仅在特定条件下使用，合并后链接器可发现其未被引用并删除。*

- **函数合并（Identical Code Folding, ICF）**  
  若多个函数逻辑相同（如编译器生成的默认构造函数），链接器可合并为同一实现。

  *示例：100个子类的默认构造函数可能被合并为一个。*

### (3) 调试信息压缩
- **调试符号去重**  
  调试信息（如DWARF格式）中重复的类型名称、文件路径等元数据在合并后被压缩，减少体积。