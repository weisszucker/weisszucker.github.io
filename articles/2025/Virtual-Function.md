# C++虚函数

> Wrapper.

## 虚函数实现机制

编译器为包含虚函数的类生成一个唯一的虚函数表（vtable），存储该类所有虚函数的实际实现地址。该表
存放在只读数据段(如`.rodata`)，在程序加载时初始化。

每个包含虚函数类的实例对象有一个指向vtable的指针(vptr)，确保指向正确的虚函数。

在进行虚函数调用时，首先找到vptr，然后通过函数偏移量（编译期确定）确定目标函数在vtable中的地址。然后跳转到该函数。

## 性能开销

### 虚函数调用的额外开销

虚函数调用需要获取vptr，访问vtable，获取目标函数地址后跳转执行。相对普通成员函数多了2-3次内存访问。

### 无法内联优化

虚函数的目标在运行时确定，编译器无法在编译期静态绑定，因此无法内联。

影响：高频调用的小型函数（如getter/setter）若为虚函数，性能损失显著。

```cpp
// 非虚函数（可内联）
int getValue() { return value; } // 可能被优化为直接寄存器访问

// 虚函数（无法内联）
virtual int getValue() { return value; } // 必须通过vtable调用
```

### 缓存效率影响

- **缓存未命中风险：**

    - 虚函数调用需要访问vptr和vtable，若这些数据不在CPU缓存中，会导致缓存未命中（Cache Miss），增加延迟。
    普通成员函数地址在编译器确定，不影响cpu缓存。

    - 典型影响：在紧密循环中频繁调用虚函数，可能使性能下降10倍以上。

- **内存布局优化：**

    - 虚函数导致对象内存分散（因vptr插入），可能破坏数据局部性，影响缓存利用率。

### 限制编译器优化

编译器无法确定虚函数具体实现，因此无法进行激进优化（如常量传播、死代码消除）。

### 内存开销

类实例需额外存储一个vptr。对大量小对象（如粒子系统中的粒子类）可能导致内存占用显著增加。

## final关键字

`final` 关键字限制虚函数的重写，部分场景能够让编译器确定虚函数的具体实现，无需再进行查表操作(Devirtualization)。
后续编译器还可能进行内联等优化。
